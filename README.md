# paradigms

## Домашнее задание 1. Обработка ошибок<br>
Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:<br>
ошибки разбора выражений;<br>
ошибки вычисления выражений.<br>
Для выражения 1000000*x*x*x*x*x/(x-1) вывод программы должен иметь следующий вид:<br>
x       f<br>
0       0<br>
1       division by zero<br>
2       32000000<br>
3       121500000<br>
4       341333333<br>
5       overflow<br>
6       overflow<br>
7       overflow<br>
8       overflow<br>
9       overflow<br>
10      overflow<br>
Результат division by zero (overflow) означает, что в процессе вычисления произошло деление на ноль (переполнение).<br>
При выполнении задания следует обратить внимание на дизайн и обработку исключений.<br>
Человеко-читаемые сообщения об ошибках должны выводиться на консоль.<br>
Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).<br>

## Домашнее задание 2. Вычисление в различных типах<br>
Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.<br>

Создайте класс expression.generic.GenericTabulator, реализующий интерфейс expression.generic.Tabulator:<br>

    public interface Tabulator {<br>
        Object[][][] tabulate(<br>
            String mode, String expression, <br>
            int x1, int x2, int y1, int y2, int z1, int z2<br>
        ) throws Exception;<br>
    }<br>
Аргументы<br>

mode — режим работы<br>
Режим	Тип<br>
i	int с детекцией переполнений<br>
d	double<br>
bi	BigInteger<br>
expression — вычисляемое выражение;<br>
x1, x2; y1, y2; z1, z2 — диапазоны изменения переменных (включительно).<br>
Возвращаемое значение — таблица значений функции, где R[i][j][k] соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть null.<br>

Доработайте интерфейс командной строки:<br>
Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производиться вычисления:<br>
Опция	Тип<br>
-i	int с детекцией переполнений<br>
-d	double<br>
-bi	BigInteger<br>
Вторым аргументом командной строки программа должна принимать выражение для вычисления.<br>
Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.<br>
Реализация не должна содержать непроверяемых преобразований типов.<br>
Реализация не должна использовать аннотацию @SuppressWarnings.<br>
При выполнении задания следует обратить внимание на простоту добавления новых типов и операций.<br>

## Домашнее задание 3. Бинарный поиск<br>
Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.<br>
На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.<br>
Для main, функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.<br>
Интерфейс программы.<br>
Имя основного класса — search.BinarySearch.<br>
Первый аргумент командной строки — число x.<br>
Последующие аргументы командной строки — элементы массива a.<br>
Пример запуска: java search.BinarySearch 3 5 4 3 2 1. Ожидаемый результат: 2.<br>

## Домашнее задание 4. Очередь на массиве<br>
Определите модель и найдите инвариант структуры данных «очередь».<br>
Определите функции, которые необходимы для реализации очереди.<br>
Найдите их пред- и постусловия, если очередь не может содержать null.<br>
Реализуйте классы, представляющие циклическую очередь на основе массива.<br>
Класс ArrayQueueModule должен реализовывать один экземпляр очереди с использованием переменных класса.<br>
Класс ArrayQueueADT должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).<br>
Класс ArrayQueue должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).<br>
Должны быть реализованы следующие функции (процедуры) / методы:<br>
enqueue – добавить элемент в очередь;<br>
element – первый элемент в очереди;<br>
dequeue – удалить и вернуть первый элемент в очереди;<br>
size – текущий размер очереди;<br>
isEmpty – является ли очередь пустой;<br>
clear – удалить все элементы из очереди.<br>
Модель, инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.<br>
Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.<br>
Напишите простые тесты к реализованным классам.<br>
Классы ArrayQueueADT и ArrayQueue должны быть параметризованы и типобезопастны.<br>

## Домашнее задание 5. Очереди<br>
Определите интерфейс очереди Queue и опишите его контракт.<br>
Реализуйте класс LinkedQueue — очередь на связном списке.<br>
Выделите общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue.<br>
Все классы и интерфейсы должны быть параметризовани и типобезопастны.<br>
Это домашнее задание связано с предыдущим.<br>

## Домашнее задание 6. Функциональные выражения на JavaScript<br>
Разработайте функции cnst, variable, add, subtract, multiply, divide, negate для вычисления выражений с переменной x.<br>
Функции должны позволять производить вычисления вида:<br>
let expr = subtract(<br>
    multiply(<br>
        cnst(2),<br>
        variable("x")<br>
    ),<br>
    cnst(3)<br>
);<br>

println(expr(5));<br>
При вычислении выражения вместо переменной x подставляется значение, переданное в качестве аргумента функции expr. Таким образом, результатом вычисления приведенного примера должно быть число 7.<br>
Тестовая программа должна вычислять выражение x2−2x+1, для x от 0 до 10.<br>
Сложный вариант. Требуется дополнительно написать функцию parse, осуществляющую разбор выражений, записанных в обратной польской записи. Например, результатом<br>
parse("x x 2 - * x * 1 +")(5)<br>
должно быть число 76.<br>
При выполнении задания следует обратить внимание на:<br>
Применение функций высшего порядка.<br>
Выделение общего кода для операций.<br>

## Домашнее задание 7. Объектные выражения на JavaScript<br>
Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide, Negate для представления выражений с тремя переменными: x, y и z.<br>
Пример описания выражения 2x-3:<br>
let expr = new Subtract(<br>
    new Multiply(<br>
        new Const(2),<br>
        new Variable("x")<br>
    ),<br>
    new Const(3)<br>
);<br>

println(expr.evaluate(5, 0, 0));<br>
При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7.<br>
Метод toString() должен выдавать запись выражения в обратной польской записи. Например, expr.toString() должен выдавать «2 x * 3 -».<br>
Функция parse должна осуществлять разбор выражений, записанных в обратной польской записи. Например, результатом<br>
parse("x x 2 - * x * 1 +").evaluate(5, 0, 0)<br>
должно быть число 76, а результатом<br>
parse("x x 2 - * x * 1 +").toString()<br>
— строка «x x 2 - * x * 1 +».<br>

## Домашнее задание 8. Обработка ошибок на JavaScript<br>
Добавьте в предыдущее домашнее задание функцию parsePrefix(string), разбирающую выражения, задаваемые записью вида «(- (* 2 x) 3)». Если разбираемое выражение некорректно, метод parsePrefix должен бросать ошибки с человеко-читаемыми сообщениями.<br>
Добавьте в предыдущее домашнее задание метод prefix(), выдающий выражение в формате, ожидаемом функцией parsePrefix.<br>
При выполнении задания следует обратить внимание на:<br>
Применение инкапсуляции.<br>
Выделение общего кода для операций.<br>
Минимизацию необходимой памяти.<br>
Обработку ошибок.<br>

## Домашнее задание 9. Линейная алгебра на Clojure<br>
Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:<br>
скаляры – числа<br>
векторы – векторы чисел;<br>
матрицы – векторы векторов чисел.<br>
Функции над векторами:<br>
v+/v-/v*/vd – покоординатное сложение/вычитание/умножение/деление;<br>
scalar/vect – скалярное/векторное произведение;<br>
v*s – умножение на скаляр.<br>
Функции над матрицами:<br>
m+/m-/m*/md – поэлементное сложение/вычитание/умножение/деление;<br>
m*s – умножение на скаляр;<br>
m*v – умножение на вектор;<br>
m*m – матричное умножение;<br>
transpose – транспонирование.<br>
